### 동시성 제어

**`동시에 실행되는 트랜잭션들이 서로 간의 간섭으로 인해 일관성이 파괴되는 일을 방지하기 위해 실행 순서를 제어하는 기법`**



#### 이슈들..

1. 갱신 분실 (Lost Update) = **Dirty Write**

   ```sql
   복수의 트랜잭션이 같은 값을 읽고 독립적인 연산을 한 후 독립적으로 저장할 시 갱신 값이 분실되는 현상
   -- 예시: 초기값 100
   -- T1: 100 + 50 = 150  //덧셈연산
   -- T2: 100 * 2 = 200  //곱셈연산
   -- 잘못된 저장값 = 200   ->  즉, T1 에 대한 연산 결과가 레코드에 적용되지 않음.
   ```

2. 비완료 의존성(Uncommitted Dependency) = **Dirty Read**

   ```sql
   아직 commit되지 않은 트랜잭션의 내용을 읽으려고 하는 형상
   -- 예시: 초기값 100
   -- T1 조회 = 100
   -- T2 변경 = 100 * 2 but 커밋하지 않음!
   -- T1 조회 = 200
   ```

3. 연쇄 복기 (Cascading Rollback) 

   ```sql
   두개 이상의 트랜잭션이 수행되던중 한개의 트랜잭션이 취소될 때 나머지 다른 Transaction도 연쇄적으로 취소
   -- 회복 불가(Unrecoverable): 연쇄복귀 되어야 하는 트랜잭션들 중 하나가 종료되어 회복이 불가능해 지는 현상
   ```

4. 모순성(Inconsistency) = **Non-Repeatable Read**

   ```sql
   동일 트랜잭션에서 동일한 대상을 여러번 읽을 때 같은 select 에 대해 항상 같은 결과가 나오지 않는 현상
   -- 예시: 초기값 = 100
   -- T1 조회 = 100
   -- T1 조회 = 100
   -- T2 변경 = 100 * 2 = 200
   -- T1 조회 = 200  ->  일관성 유지 실패!
   ```


5. **Phantom Read**

   ```sql
   동일 트랜잭션에서 동일한 대상을 여러번 읽을 때 그 사이에 새로운 값(Phantom Tuple)이 삽입되어 값이 변경되는 현상
   -- 예시
   -- T1 조회 = 총 N 개의 레코드
   -- T2 삽입 
   -- T1 조회 = 총 N + 1 개의 레코드
   ```





#### 트랜잭션 스케줄(Transaction Schedule)

1. **직렬 스케줄 (Serial Schedule)**

   `각 트랜잭션들의 연산들이 끼어들기 방식이 아닌 순차적으로 실행되는 스케줄`

   - 장점: 위의 문제들이 발생하지 않음!

   - 단점: 시스템의 성능을 향상시키는 다중 프로그래밍 포기

     

2. **직렬 가능한 스케줄 (Serializable Schedule)**

   `병행 수행을 최대한 보장하면서 직렬 스케줄과 실행 결과가 동일한 스케줄`

     -> 서로 영향을 주지 않는 직렬 스케줄을 비직렬적으로 수행

   

3. **비직렬 스케줄 (Nonserial Schedule)**

   `트랜잭션의 직렬 수행 순서와 상관없이 병행 수행하는 스케줄`

   -> 인터리빙 방식으로 처리! (메모리 성능 향상, 끼워넣기)

   - 장점: CPU 활용도 높일 수 있음
   - 단점: 정확도 떨어짐





#### 스케줄 제어 기법

1. **잠금 (Lock)**

   ```sql
   하나의 트랜잭션이 실행되는 동안 특정 데이터에 대해 다른 트랜잭션이 동시에 접근하지 못하도록 독점하는 기법
   -- 예시
   -- T1: lock
   -- T2: 대기
   -- T1: unlock
   -- T2: lock  ->  잠금 설정 후 접근 
   ```

   

   *하 지 만*

   **읽기 연산의 경우 무조건 접근할 수 없게 해놓은 경우 지나치게 제한적일 수 있다!!**

   따라서, 잠금은 연산의 성격에 따라 두 가지로 분류~!

   

   ```sql
   `1. 공유잠금 (shared lock)`
       - read 가능, write 불가능
       
   `2. 배타잠금 (exclusive lock)`
       - read 가능, write 가능
   ```

2. 잠금 규칙
   - 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다.
   - 트랜잭션이 데이터 X를 읽기만 할 경우 LS를 요청하고, 읽거나 쓸 경우 LX를 요청한다.
   - 다른 트랜잭션이 데이터에 LS를 걸어둔 경우, LS의요청은 허용하고 LX는 허용하지 않는다.
   - 다른 트랜잭션이 데이터에 LX를 걸어둔 경우, LS와 LX 모두 허용하지 않는다.트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

3. **2단계 잠금 규약 (2PLP: Two-Phase Locking Protocol)**

   ```SQL
   직렬 가능성을 보장할 수 있는 규약.
   트랜잭션들이 lock하는 시간과 unlock을 하는 시간을 구분하여 수행하도록 하는 것 = 잠금 연산이 정해진 절차에 의해 수행되도록
   
   `확장 단계 (growing phase) : lock 가능, unlock 불가능`
   `축소 단계 (shrinking phase) : lock 불가능, unlock 가능`
   
   -- 모든 lock 연산이 unlock 연산 앞에서 실행 되어야 함
   -- but! 교착 상태에 빠질 수 있음
   ```

4. **교착상태 (deadlock)**

   ```sql
   두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
   -- 예시: 두 개의 데이터 항목 A, B
   -- T1: A exclusive lock
   -- T2: B shared  lock   ->   서로 다른 데이터에 대한 락, 문제 없음
   
   -- T2: A shared lock   -> T1 이 unlock 하기 전까지 대기
   -- T1: B exclusive lock   ->   T2 가 unlock 하기 전까지 대기
   `무한 대기 상태에 빠지게 됨`
   ```

5. **타임스탬프 (Timestamp)**

   ```sql
   비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법
   => 데이터에 접근하는 시간(Timestamp)을 미리 정해두어 부여된 시간 순서대로 데이터에 접근
   => 타임스탬프는 트랜잭션을 유일하게 식별할 수 있는 식별자의 역할을 할 수 있으며 트랜잭션의 시작 시간으로 간주
   -- 장점: lock을 사용하지 않고 시간을 나눠 사용하기 때문에 교착 상태(Dead lock)가 발생하지 않음
   -- 단점: Rollback 발생률이 높고 연쇄 복귀(Cascading Rollback) 를 초래할 수 있는 단점
   
   
   타임스탬프를 생성하는 방법
   - 논리적 계수기 : 계수기를 사용하여 트랜잭션이 들어올 때마다 카운터를 하나씩 증가
   - 시스템 클럭 : 시스템의 고유 시계 사용
   ```

   
