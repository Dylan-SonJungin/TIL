## 1️⃣ JWT란?

![jwt.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/1b4588a3-1312-4e59-9a42-e226809dc1f4/jwt.png)

### 1-1. J**WT의 개념과 역할**

JSON Web Token (JWT)은 웹에서 정보를 안전하게 전송하기 위한 표준 방식 중 하나로, 데이터를 JSON 객체로 표현하고 서명하여 전송하는 토큰 기반의 인증 방식이다. JWT는 클라이언트와 서버 간의 정보 교환에 사용되며, 특히 사용자 인증 및 권한 부여에 많이 활용된다.

### 1-2. **JWT의 주요 특징**

1. 가볍고 간결한 형식 **:** JWT는 JSON 기반으로 되어 있어 가독성이 높고 간결한 형식을 가지고 있다.
2. 자가 포함적(Self-contained) : JWT는 필요한 모든 정보를 자체적으로 지니고 있다. 이 정보에는 토큰이 발행한 주체, 만료 시간, 클레임 등이 포함된다.
3. 비상태성(Stateless) : JWT는 상태를 저장하지 않는 인증 방식이다. 서버는 사용자의 상태를 유지하지 않고, 클라이언트가 요청을 보낼 때마다 JWT를 통해 사용자를 식별한다.
4. 간단한 전송 **:** JWT는 HTTP와 URL을 통해 쉽게 전송될 수 있다. Base64 인코딩된 형태로 구성되어 있어 URL 파라미터나 HTTP 헤더에 포함하여 전송이 가능하다.

### 1-3. **JWT의 활용 목적**

1. **인증 :** JWT는 사용자 인증에 주로 사용된다. 사용자가 로그인하면, 서버는 사용자에게 JWT를 발행하고, 사용자는 이후 요청마다 이 토큰을 헤더에 포함시켜 인증 정보를 제공한다.
2. **정보 교환:** JWT는 클라이언트와 서버 간의 정보를 안전하게 교환하는 데에 사용된다. 토큰이 서명되어 있기 때문에 변조가 어렵다. 정보는 JWT 내에 저장되며, 시그니처를 통해 정보의 무결성이 보장된다.
3. **권한 부여(Authorization) :** JWT는 사용자가 특정 리소스에 대한 접근 권한을 가지고 있는지를 확인하는 데 사용된다. 토큰 내의 클레임을 통해 사용자의 권한을 판단할 수 있다.

## 2️⃣ JWT의 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/f5d805cb-fa01-481f-b8e5-83b184ddb096/Untitled.png)

JWT는 세 가지 부분으로 이루어져 있다. 각 부분은 `Base64`로 인코딩되며, 점('.')으로 구분된다.

### Header, Payload, Signature의 구성과 역할

1. **Header (헤더) :** JWT의 유형 과 사용된 해싱 알고리즘을 정의한다. 일반적으로 타입은 "JWT"이고, 해싱 알고리즘이 `HS256` 또는 `RS256`이다.

   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

   여기서 `alg`는 사용된 알고리즘을 나타내며, `typ`는 토큰의 타입을 나타낸다.

2. **Payload (페이로드) :** 페이로드는 토큰에서 전송하려는 데이터를 포함한다. 이 데이터는 클레임(Claims)라고 하며, 등록된(Registered) 클레임, 공개(Public) 클레임, 비공개(Private) 클레임 이 세가지로 유형으로 나눠진다.

   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "iat": 1516239022
   }
   ```

   여기서 `sub`는 주제를 나타내는 등록된 클레임이고, `name`은 비공개 클레임이다. `iat`은 발행 시간을 나타내는 등록된 클레임이다.

3. **Signature (서명) :** 시그니처는 토큰의 안전을 보장한다. 헤더와 페이로드를 합친 후, 이를 비밀키를 사용하여 인코딩한다. 시그니처는 토큰이 변조되지 않았음을 확인하는 데 사용된다.

   ```scss
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret)
   ```

   여기서 `HMACSHA256`는 사용된 해싱 알고리즘을 나타내고, `header`와 `payload`는 각각 헤더와 페이로드를 base64Url로 인코딩한 것이다. `secret`은 비밀 키이다.

   이렇게 생성된 시그니처는 토큰의 마지막 부분에 추가되며, 이를 통해 토큰이 변조되지 않았음을 확인할 수 있다.

## 3️⃣ **JWT의 생성과 전송, 검증 과정**

### 3-1. 웹 앱에서 사용자 인증

먼저 사용자가 웹 애플리케이션에 로그인 요청을 보낸다. 이 요청은 보통 사용자의 아이디와 비밀번호를 포함한다.

### 3-2. JWT 토큰 생성

서버는 사용자의 인증정보를 검증하고 인증이 성공하면 서버는 사용자의 정보와 서버 설정 등을 바탕으로 JWT를 생성한다. 이 JWT에는 사용자를 식별할 수 있는 정보(ex : 사용자 아이디)와 만료 시간 등이 포함된다. 생성된 JWT는 클라이언트에게 전송된다. 클라이언트는 이 토큰을 저장한다.

1. **Header와 Payload 작성**

   - Header와 Payload에 들어갈 클레임을 작성한다. 클레임에는 공개 클레임, 등록된 클레임 등이 포함된다.
   - Header와 Payload를 JSON 형식으로 표현하고, Base64로 인코딩한다.

   ```json
   // Header
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   
   // Payload
   {
     "sub": "1234567890",
     "name": "John Doe",
     "iat": 1516239022
   }
   ```

2. **Signature 생성**

   - 선택한 서명 알고리즘(**`alg`**)과 함께 Header와 Payload를 서명한다.
   - 서명 결과를 Base64로 인코딩한다.

   ```scss
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret
   )
   ```

3. **JWT 생성**

   - 인코딩된 Header, Payload, Signature를 합쳐 JWT를 생성한다.

   ```
   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogIkpvaG4gRG9lIiwgImlhdCI6IDE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
   ```

### 3-3. JWT 토큰 전송

클라이언트는 서버에 요청을 보낼 때마다 HTTP 헤더에 저장해둔 JWT 토큰을 첨부한다.

- HTTP 요청에 토큰 추가

  - 클라이언트는 생성된 JWT 토큰을 HTTP 요청의 `Authorization` 헤더에 추가한다. 여기서 `Autorization`은 HTTP 프로토콜에서 클라이언트의 인증 정보를 서버에 전달하는 헤더이다. `Bearer`는 HTTP 인증 헤더에서 사용되는 스키마 중 하나로, 주로 액세스 토큰(Access Token)을 전송하는 데 사용된다.

    ```scss
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJuYW1lIjogIkpvaG4gRG9lIiwgImlhdCI6IDE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ```

### 3-4. JWT 토큰 검증

서버는 요청을 받을 때마다 Authorization 헤더를 확인하여 JWT를 추출하고, 이를 검증한다. 검증 과정에서는 토큰이 변조되지 않았는지와 만료되지 않았는지를 확인한다. JWT가 유효하다면, 서버는 요청을 처리하고 응답을 클라이언트에게 전송한다. JWT가 유효하지 않다면, 에러 메시지와 함께 요청을 거부한다.

1. JWT 파싱
   - 수신한 JWT를 "."을 기준으로 Header, Payload, Signature로 분리한다.
   - 각 부분을 Base64 디코딩하여 원본 데이터를 얻는다.
2. 서명 검증
   - Header에서 지정된 알고리즘을 사용하여 서버에 저장된 비밀키로 서명을 검증한다.
   - 서명이 유효하면 해당 토큰을 신뢰할 수 있다고 판단한다.
3. 클레임 검증
   - Payload의 클레임들을 확인하고, 필요한 정보를 추출하여 사용한다.
   - 만료 시간 등을 확인하여 토큰의 유효성을 판단한다.

## 4️⃣ Access Token과 Refresh Token

JWT에 대해 찾아보면 Access Token과 Refresh Token에 대한 얘기가 꼭 함께 나온다. **Access Token과 Refresh Token은 JWT를 사용하는 구체적인 인증 토큰의 예시라고 할 수 있다.** 그렇다면 Access Token과 Refresh Token은 뭘까?

### 4-1. Access Token이란?

Access Token은 사용자의 인증 정보를 담은 토큰으로, 주로 사용자가 서버에 요청을 보낼 때 해당 사용자를 인증하는 데 사용된다. 즉, 사용자가 자신이 누구인지 증명하는 수단이다.

### 4-2. Refresh Token이란?

Refresh Token은 Access Token을 재발급 받을 수 있는 권한을 부여하는 토큰이다. Access Token이 만료되었을 경우, 사용자는 Refresh Token을 이용해 새로운 Access Token을 받아 인증을 유지할 수 있다.

### 4-3. Access Token과 Refresh Token의 차이점

Access Token과 Refresh Token은 모두 사용자 인증에 사용되는 토큰이지만, 그 목적과 수명, 그리고 사용 방식 등에서 차이가 있다.

Access Token은 일정 시간 후에 만료되며, 만료 시간은 일반적으로 짧게 설정된다. 이렇게 하면, 토큰이 탈취되더라도 공격자가 제한된 시간 동안만 사용할 수 있다. 일반적으로 클라이언트 측에 저장되며 서버에 요청을 보낼 떄마다 이 토큰을 함께 보내게 된다. 웹 브라우저에서는 HTTP Only 쿠키, Local Storage, Session Storage 등을 사용해 Access 토큰을 저장할 수 있다. 그러나 이 중 HTTP Only 쿠키를 사용하는 것이 XSS 공격으로부터 토큰을 보호하는 데 가장 효과적이다.

<aside> ❓ **HTTP only 쿠키란?**

HTTP Only 쿠키는 웹 브라우저에서 자바스크립트를 통한 접근이 불가능한 쿠키를 말한다. 이는 웹사이트가 사용자의 웹 브라우저에 데이터를 저장할 때 사용하는 방법 중 하나이다.

HTTP Only 속성이 설정된 쿠키는 웹 서버와 웹 브라우저 간에 HTTP(S) 요청을 통해서만 읽고 쓸 수 있다. 이렇게 하면, 클라이언트 측 스크립트(ex. 자바스크립트)를 통한 쿠키의 접근이 제한되므로, 크로스 사이트 스크립팅(XSS) 공격으로부터 쿠키를 보호할 수 있다.

따라서, 보안이 중요한 데이터(ex. 세션 토큰 등)를 저장할 때 HTTP Only 쿠키를 사용하는 것이 좋다.

</aside>

반면에, Refresh Token은 Access Token이 만료되었을 때 사용자가 새로운 Access Token을 받기 위해 사용하는 토큰이다. Refresh Token은 일반적으로 Access Token보다 긴 만료 시간을 가지며, 사용자는 이 토큰을 사용해 새로운 Access Token을 요청할 수 있다. 보안상의 이유로 서버측에서 관리되는게 일반적이다.

따라서, Access Token은 직접적인 사용자 인증에 사용되며, Refresh Token은 Access Token이 만료된 후에 새로운 Access Token을 발급받는 데 사용된다.

![스크린샷 2022-06-09 오후 4.12.24.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/ba554bcd-4562-4aea-ad02-87cb4159d676/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.12.24.png)

## 5️⃣ JWT의 보안

JWT는 웹 애플리케이션에서 인증과 인가를 처리하는 데에 유용한 도구이지만, 그 자체가 완벽하게 안전한 방법이라고 볼 수는 없다. 예를 들어, 토큰 유출은 JWT의 주요 취약점 중 하나이다. JWT는 클라이언트 측에 저장되고, HTTP 헤더를 통해 전송되므로, 토큰이 유출되면 해당 토큰을 이용하여 서버에 무단으로 접근할 수 있다. 따라서 JWT를 사용할 때에는 항상 보안에 신경 써야 한다.

### 5-1. JWT의 보안 취약점

- ```
  토큰 유출
  ```

  - JWT의 주요 취약점 중 하나이다. JWT는 클라이언트 측에 저장되고, HTTP 헤더를 통해 전송되므로, 토큰이 유출되면 해당 토큰을 이용하여 서버에 무단으로 접근할 수 있다.

- ```
  크로스 사이트 스크립팅 : XSS
  ```

  - JWT를 로컬 스토리지나 세션 스토리지에 저장하면 `XSS 공격`에 취약해질 수 있다. 여기서 `XSS`란 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해 사용자의 세션을 가로채거나, 웹사이트를 변조하거나, 악의적 콘텐츠를 삽입하거나, 피싱 공격을 진행하는 것을 말한다. 웹 애플리케이션에서 로컬 스토리지나 세션 스토리지는 브라우저에서 실행되는 JavaScript 코드를 통해 접근할 수 있기 때문에 XSS 공격을 당할 수 있으며, 토큰을 탈취당할 수 있다.

- ```
  크로스 사이트 요청 위조 : CSRF
  ```

  - JWT를 쿠키에 저장하면 CSRF 공격의 위험도 있다. CSRF 공격은 공격자가 사용자를 속여 사용자의 권한으로 웹사이트의 기능을 실행하게 만드는 공격이다. JWT가 쿠키에 저장되어 있으면, 공격자는 사용자를 속여 웹사이트에 요청을 보낼 수 있고, 이 요청에는 사용자의 JWT가 포함되어있기 때문에 서버는 이 요청을 사용자 본인이 보낸 것처럼 인식하게 된다. 결과적으로 공격자는 사용자의 권한을 도용하여 웹사이트의 기능을 실행할 수 있게 된다.

### 5-2. JWT 보안 강화 방법

1. 알고리즘 선택
   - 대칭키 알고리즘인 HMAC 대신 RSA 또는 ECDSA와 같은 비대칭키 알고리즘을 사용하면 보안성이 향상된다.
2. 만료 시간 설정
   - 만료 시간을 길게 설정할 경우 토큰이 탈취당했을 때 해당 토큰이 긴 시간 악용될 우려가 있다. 짧은 만료 시간을 설정하면 토큰이 탈취당하더라도 금방 만료되기 때문에 보안이 향상된다. 하지만 만료 시간이 너무 짧으면 사용자가 자주 인증을 해야해서 사용자 경험이 나빠지므로 적절한 만료 시간을 설정하는 것이 중요하다.
3. 정보 최소화
   - 토큰에는 필요한 최소한의 정보만을 담도록 한다. 민감한 정보는 서버 측에서 안전하게 관리하고, 토큰에는 식별자와 권한 등 필요한 최소한의 정보만을 포함시켜서 토큰이 탈취되었을 때 노출되는 정보를 최소화한다.
4. HTTPS 사용
   - JWT를 전송할 때는 HTTPS를 사용하여 통신을 암호화하는 것이 중요하다. 암호화되지 않은 통신은 중간자 공격 등에 취약할 수 있다.

## 6️⃣ JWT와 관련된 표준 및 규격

이제 JWT와 관련된 두 가지 중요한 표준, 즉 OAuth와 OpenID Connect에 대해 살펴보자. 이 두 표준 규격은 JWT를 활용해서 사용자의 인증 정보와 권한을 표현한다. OAuth와 OpenID Connect는 각각 서로 다른 목적과 기능을 가지고 있지만, 둘 다 사용자 인증 및 인가에 있어서 중요한 역할을 한다.

### OAuth, OpenID Connect와 JWT

1. OAuth (Open Authorization)
   - OAuth는 서비스 간의 인증 및 권한 부여를 위한 표준 프로토콜로, 제 3의 서비스에게 사용자의 데이터에 대한 제한적인 접근 권한을 부여한다.
   - 주로 소셜 미디어 플랫폼과 같은 서비스 간의 연동 시에 활용되며, 사용자의 동의를 받아 특정 리소스에 접근할 수 있도록 한다.
   - **사용자가 어떤 서비스(ex. SNS)에 제한적인 접근 권한을 부여할 수 있게 해주는데, 이때 JWT가 접근 토큰으로 사용된다. 이 접근 토큰 안에는 사용자의 인증 정보와 접근 권한이 들어있어있다.**
2. OpenID Connect
   - OpenID Connect은 OAuth 2.0 기반으로 작동하는 사용자의 디지털 ID를 제공하고 관리하기 위한 프로토콜이다. JWT를 사용하여 사용자 정보를 전달하고, 인증 및 권한을 제공한다.
   - 웹 및 모바일 애플리케이션에서 사용자를 식별하고, 인증 및 권한을 관리하는 데 사용된다.
   - **사용자 인증을 위한 ID 토큰으로 JWT를 활용한다. 이 ID 토큰에는 사용자를 식별할 수 있는 정보가 들어있고, 이를 통해 사용자가 누구인지를 신뢰할 수 있게 해준다.**

### OAuth와 OpenID Connect의 차이점

OAuth는 주로 서비스 간의 권한 부여를 위한 것이며, 사용자의 데이터 접근을 중심으로 한다. 반면 OpenID Connect는 사용자의 디지털 ID를 안전하게 제공하고, 사용자를 인증하고 권한을 부여하는 데에 중점을 둔다.