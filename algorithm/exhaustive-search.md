## 완전탐색 (Exhaustive Search)

>**모든 가능한 경우의 수**를 탐색하여 최적의 결과를 찾는 방법
>
>모든 가능성을 고려하기 때문에 항상 최적의 해를 찾을 수 있지만 경우의 수가 매우 많은 경우 시간과 메모리의 부담



|     알고리즘      | 특징                                                         | 장점                                             | 단점                                            |
| :---------------: | ------------------------------------------------------------ | ------------------------------------------------ | :---------------------------------------------- |
|  **브루트 포스**  | 모든 가능한 조합을 시도하여 원하는 결를 찾음                 | 구현이 간단하며, 모든 경우를 탐색할 수 있음      | 시간 복잡도가 크게 증가할 수 있음               |
|   **백트래킹**    | 조건에 맞지 않으면 해당 가지치기 후 다른 경우로 이동         | 일부 경우의 가지치기를 통해 효율적으로 탐색 가능 | 스택오버플로우 발생할 수 있음                   |
|  **비트 마스크**  | 모든 경우의 수를 이진수로 표현하고 비트 연산을 통해 원하는 결과를얻 | 메모리 사용이 효율적이며, 연산 속도가 빠름       | 문제에 따라 비트 표현이 복잡해질 수 있음        |
|   **재귀 함수**   | 재귀적 호출을 통해 모든 경우를 탐색                          | 코드의 간결성과 가독성이 좋음                    | 깊은 재귀 호출 시 스택 오버플로우 가능성이 있음 |
| **순열 알고리즘** | 순열을 생성하여 문제 해결<br />(순열은 서로 다른 n개 중에서 r개를 선택하여 나열하는 방법) | 특정 순서의 순열을 쉽게 생성 가능                | 경우의 수가 많을 경우 시간 오래걸림             |
|      **DFS**      | 깊이 우선 탐색을 사용하여 가능한 모든 경로를 탐색            | 그래프 구조에서 높은 유연성을 제공               | 최악의 경우 모든 경로를 탐색해야 할 수 있음     |
|      **BFS**      | 너비 우선 탐색을 사용하여 가능한 모든 상태를 탐색            | 최단 경로 문제에서 효과적으로 사용 가능          | 최악의 경우 모든 경로를 탐색해야 할 수 있음     |



### 브루트 포스 (Brute Force)

> 단순한 힘 = 냅다 다 해보기..><
>
> 1. **for / while 루프** 활용
> 2. **재귀함수**

<img src="https://slideplayer.com/slide/8709386/26/images/2/The+Brute-Force+Algorithms.jpg" alt="6.4: The Brute-Force Algorithms - ppt video online download" style="zoom:67%;" />







### 비트마스트 (Bit Mask)

> 이진수 표현을 활용하여 집합의 부분집합을 나타내는 기법으로, 비트 연산을 사용하여 집합 연산을 간결하게 처리
>
> *집합에 속하는 원소의 인덱스를 이진수의 비트로 표현하고 해당 비트가 1이면 집합에 속하는 것으로 간주*

| 연산자 | 설명                                           | 예시                  |
| ------ | ---------------------------------------------- | --------------------- |
| `&`    | AND 연산: 두 비트가 모두 1이면 1, 아니면 0     | `1010 & 1100 = 1000`  |
| `|`    | OR 연산: 두 비트 중 하나라도 1이면 1, 아니면 0 | `1010 \| 1100 = 1110` |
| `^`    | XOR 연산: 두 비트가 다르면 1, 같으면 0         | `1010 ^ 1100 = 0110`  |
| `~`    | NOT 연산: 비트를 반전                          | `~1010 = 0101`        |
| `<<`   | 왼쪽 시프트: 비트를 왼쪽으로 이동              | `1010 << 2 = 1000`    |
| `>>`   | 오른쪽 시프트: 비트를 오른쪽으로 이동          | `1010 >> 2 = 0010`    |

